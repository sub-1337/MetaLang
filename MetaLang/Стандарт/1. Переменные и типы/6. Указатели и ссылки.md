
Указатели это число, определяющее место в памяти (при нативной
сборке) и хэндлер при эмуляции указателей.
Ранее мы уже познакомились с типом присваивания `ref` [[4. Виды присвоений]]
Указатели достигают той же цели, но в немного ином формате.

Указатели снабжаются символом `$` или `ptr(...)`
Так возникнет меньше путаницы и не нужно специальных символов
для обращения по адресу, на который указывает это  указатель.

```
var<string> str = "Hello";
var<ptr<string>> $str_p = $str;
var<ptr<string>> ptr(str_p2) = ptr(str)
print(str_p); // Напечатает Hello
print(str_p2); // Напечатает Hello
```

```
var<const ptr<string>> $a; // константный указхатель
var<ptr<const string>> $b; // указатель на константну
```

Если указатель вложенный он требует несколько символов 
и вложенности. Можно использовать ключевое слово `@nest`.
Эти объявления одинаковы.
```
var<ptr<ptr<string>>> $$c;
var<ptr<@nest 2,string> $(@nest 2)d;
```

Указатель может имеет специальный тип `null`.
Компилятор автоматически проверяет указатель при использовании
Так что вы не поймаете сегфолт при использовании null.
Но это поведение можно отключить в качестве оптимизации
`#compiler.no_null_check = true;`

Вы можете явно проверить корректность переменной заданной 
через указатель
```
is_null(a)
```
Или
```
if($a)
print(a)
```

Есть ещё один оператор для проверки корректности переменной
```
is_ok(a)
```
Такой способ проверок проверяет также диапазон значений. 
Для проверки переменной данный способ является приоритетным.

Умные указатели.
Мы можем назначить тип умного указателя. При этом методика работы с ним
будет та же, замена одного типа умного указателя на другой и сырой будет
безболезненна.

Список умных указателей:
1) `unique`
2) `shared`
3) `weak`

```
fn test(var<int> ptr.shared(a)) -> void
{
    a = a + 5;
}

var<int> a = 10;
var<ptr shared int> $b = ptr.shared(int(5)); // Слово new опускается

test(b);

// Напечатает 10
print(a);
// Напечтатает 10
print(b);
```

### Оператор `new`

В языке нет необходимости в операторе `new` 
вместо него память автоматически выделяется.

Оператор new всё же может иметь место, если мы оперируем памятью 
в небезопасной манере.