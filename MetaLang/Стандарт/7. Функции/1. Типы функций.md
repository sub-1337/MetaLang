Типы функций

Функции бывают по времени выполнения:

- статические, времени компиляции (prep)
- времени выполнения (runtime)
- дефолтная, индеферрентная (default)

Простая функция. Гарантируется одинаковый результат при одинаковых параметрах при отсутствии сайд эффектов. Стандартная функция не определяет время выполнения (статика/рантайм) и не определяет тип (интерпретируемая/обычная) поэтому является индефферентной.

```
fn Test()
{

}
```

Функция препроцессинга. Исполняется на этапе компиляции. Аналог constexpr и в некотором роде макросов в с++

```
prep fn Test()
{

}
```

Функция явно этапа исполнения.

```
runtime fn Test()
{

}
```

Функции могут быть интерпретируемыми. В таком случае они будут выполняться внутри среды интерпретации, добавляемой по усмотрению программиста в текущий проект.

Функции также могут быть:

- интерпретируемыми
- нативными

Интерпретируемые функции это interp

```
interp fn Test()
{

}
```

В противовес интерпретируемым есть обычные функции native

```
native fn Test()
{

}
```

native функции могут иметь некоторые другие расширения. Например stdcall, cdec и fastcall.

Правильный тип позволяет смешивать c++ код и код на нашем языке.

Для функции можно описать тип отдельно и использовать где-то ещё.

За это отвечает следующая конструкция:

```
var<const type.func> t = [@runtime,@native.stdcall]
*t fn Test()
{

}
```

Это аналогично

```
runtime native.stdcall fn Test()
{

}
```

Данное расширение в некотором пределе замещает злополучную практику использования макросов.
