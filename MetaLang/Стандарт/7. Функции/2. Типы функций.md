Типы функций

### Контекст исполнения

Функции бывают по контексту выполнения:

- статические, времени компиляции (prep)
- времени выполнения (runtime)
- дефолтная, индеферрентная (default)

Простая функция. Гарантируется одинаковый результат при одинаковых параметрах при отсутствии сайд эффектов. Стандартная функция не определяет время выполнения (статика/рантайм) и не определяет тип (интерпретируемая/обычная) поэтому является индефферентной.

```
fn Test()
{

}
```

Функция **constexpr**. Исполняется на этапе компиляции. Аналог constexpr и в некотором роде макросов в с++

```
constexpr fn Test()
{

}
```

Функция явно этапа исполнения.

```
runtime fn Test()
{

}
```

Функции могут быть интерпретируемыми. В таком случае они будут выполняться внутри среды интерпретации, добавляемой по усмотрению программиста в текущий проект.

Функции также могут быть:

- интерпретируемыми
- нативными

Интерпретируемые функции это interp

```
interp fn Test()
{

}
```

В противовес интерпретируемым есть обычные функции native

```
native fn Test()
{

}
```

native функции могут иметь некоторые другие расширения. Например stdcall, cdec и fastcall.

Правильный тип позволяет смешивать c++ код и код на нашем языке.

Для функции можно описать тип отдельно и использовать где-то ещё.

За это отвечает следующая конструкция:

```
var<const type.func> t = [@runtime,@native.stdcall]
*t fn Test()
{

}
```

Это аналогично

```
runtime native.stdcall fn Test()
{

}
```

Данное расширение в некотором пределе замещает злополучную практику использования макросов.

Функции могут быть перегружены по типу. К примеру этот код вызовет
первую функцию во время компиляции и вторую в процессе выполнения:
```
fn constexpr func() -> var
{
    return "init";
}
fn runtime func() -> var
{
    return "run";
}

var<const> a = func();
main()
{
    var b = func();
    print(a); // init
    print(b); // run
}
```
 
### Прочие модификаторы

**noexcept**
Функция помеченная как noexcept гарантирует что функция не будет выбрасывать исключений. Прямой аналог из c++.

**pure**
Функции могут быть помечены как pure. В таком случае они гарантированно не вызывают сайд эффектов, такие как выброс исключение, или вызов не-pure функций.
Функции pure гарантированно возвращают на один и тот же набор параметров один и тот же вывод.
Pure функции могут использоваться для вычисления констант на этапе компиляции. При передаче в функцию const значений функция работает как constexpr.
```
fn pure add(var a, var b) -> var
{
    return a + b;
}

var<const> c = add(1,2); // == 3
```

