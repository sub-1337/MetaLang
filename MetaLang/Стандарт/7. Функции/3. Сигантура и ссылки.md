### Типы аргументов, сигнатура

Функции имеют свою уникальную сигнатуру.
```
fn isEqual(var<int> a, var<int> b) -> var<bool>
{
    return a == b;
}
```

Возможны манипуляции с функцией как с объектом.
Самое гарантированное и быстрое - явное задание делегата функции и сохранение функции в ней. 
Менее гарантированное - полностью автоматический вывод типа функции и вызов.

```
fn add(var<int> a, var<int> b) -> var<int>
{
    return a + b;
}

// Явное задание делегата
var<type.delegate> del = fn.delegate(var<int>, var<int> ; var<int>);
var<del> func = add;
print(func(1,3)); // Напечатает 4

// Выведение типа делегата
var<type.delegate> del2 = add
var<del2> func2 = add
print(func2(1,3)) // Напечатает 4

// Автоматическое разрешение функции
var<fn> func3 = add
print(func3(1,3)) // Напечатает 4
```

### pre и inline
pre функции и inline  функции не имеют адреса соответственно не имеют ссылки. Но это поведение можно изменить через флаг процессора 
`#compiler.allow_inline_runtime = true`  и `#compiler.allow_pre_runtime = true` Это создаст эти функции во время исполнения
и они могут быть вызваны отладчиком в режиме интерпретации.

### Множественный возврат
```
fn func() -> (var a, var b)
{
    return 10, "ten";
}
```